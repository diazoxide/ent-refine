{{- /* gotype: github.com/entkit/entkit.Generator */ -}}

{{- define "src/app.tsx" -}}
{{- $prefix := $.Extension.Prefix }}
import React, {useState} from "react";
import {AuthBindings,Authenticated, Refine} from "@refinedev/core";
import {
    ErrorComponent,
    notificationProvider,
    RefineThemes,
} from "@refinedev/antd";
import { ConfigProvider } from "antd";
import "@refinedev/antd/dist/reset.css";
import {GraphQLClient} from "graphql-request";
import dataProvider from "./data-provider";
import routerProvider, {
    NavigateToResource,
    CatchAllNavigate,
    UnsavedChangesNotifier,
} from "@refinedev/react-router-v6";
import { BrowserRouter, Routes, Route, Outlet } from "react-router-dom";
import { RoutesBundle } from "./routes";
import * as environment from "./environment";
import * as AntdIcons from "@ant-design/icons";
{{- if $.Extension.Auth.Enabled }}
{{- if $.Extension.Auth.Keycloak.Enabled}}
import {useKeycloak} from "@react-keycloak/web";
{{- end }}
import {getPermissions} from "./auth";
import { usePermissions } from "@refinedev/core";
{{- end }}

const client = new GraphQLClient(environment.graphqlUrl);

function App() {

    {{- if $.Extension.Auth.Enabled }}
    const [permissions, setPermissions] = useState<any|undefined>();

    {{- if $.Extension.Auth.Keycloak.Enabled }}
    const { keycloak, initialized } = useKeycloak();
    if (!initialized) {
        return <div>Loading...</div>;
    }
    const authProvider: AuthBindings = {
        login: async () => {
            const urlSearchParams = new URLSearchParams(window.location.search);
            const { to } = Object.fromEntries(urlSearchParams.entries());
            await keycloak.login({
                redirectUri: `${window.location.origin}${to || ""}`,
            });

            return {
                success: false,
                error: new Error("Login failed"),
            };
        },
        logout: async () => {
            try {
                await keycloak.logout({
                    redirectUri: window.location.origin,
                });
                return {
                    success: true,
                    redirectTo: "/login",
                };
            } catch (error) {
                return {
                    success: false,
                    error: new Error("Logout failed"),
                };
            }
        },
        onError: async (error) => {
            console.error(error);
            return { error };
        },
        check: async () => {
            try {
                const { token } = keycloak;
                if (token) {
                    client.setHeaders({Authorization: `Bearer ${token}`})
                    return {
                        authenticated: true,
                    };
                } else {
                    return {
                        authenticated: false,
                        logout: true,
                        redirectTo: "/login",
                        error: new Error("Token not found"),
                    };
                }
            } catch (error) {
                return {
                    authenticated: false,
                    logout: true,
                    redirectTo: "/login",
                    error: new Error("Token not found"),
                };
            }
        },
        getPermissions: async ()=> {
            return new Promise((resolve, reject) => {
                {{- if $.Extension.Auth.Keycloak.Enabled -}}
                keycloak.updateToken(30).then(() => {
                    fetch(keycloak.authServerUrl + '/realms/' + keycloak.realm + '/protocol/openid-connect/token',
                        {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/x-www-form-urlencoded',
                                'Authorization': 'Bearer ' + keycloak.token,
                            },
                            body: `grant_type=urn:ietf:params:oauth:grant-type:uma-ticket&response_include_resource_name=true&response_mode=permissions&audience=${environment.keycloakBackendClientId}`
                        })
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('Failed to get permissions');
                            }
                            return response.json();
                        })
                        .then(data=>{
                            const res: Record<string, string[]> = {}
                            data.forEach((p: { rsname: string, scopes: string[] })=>{
                                res[p.rsname.replace(/^{{ $prefix }}/, "")] = p.scopes.map(s=>s.replace(/^{{ $prefix }}/, ""));
                            })
                            setPermissions(res)
                            resolve(res)
                        })
                        .catch(error => reject(error));
                }).catch(error => reject('Failed to update token:'+ error.message));
                {{- end }}
            });
        },
        getIdentity: async () => {
            if (keycloak?.tokenParsed) {
                return {
                    name: keycloak.tokenParsed.family_name,
                };
            }
            return null;
        },
    };
    {{- end }}
    {{- end }}

    return (
        <BrowserRouter>
            <ConfigProvider theme={RefineThemes.Blue}>
                <Refine
                    {{- if $.Extension.Auth.Enabled }}
                    authProvider={authProvider}
                    {{- end }}
                    routerProvider={routerProvider}
                    dataProvider={dataProvider(client)}
                    notificationProvider={notificationProvider}
                    catchAll={<ErrorComponent/>}
                    resources={
                        [
                            {{- range $n := $.Graph.Nodes}}
                            {{- $routePath := $n.Annotations.ENTKIT.Route }}
                            {{- if empty $routePath}}
                            {{- $routePath = $n.Name | kebabcase }}
                            {{- end }}
                            {
                                name: "{{ $n.Name | kebabcase }}",

                                {{- $action := ER_getActionByName $n "list" }}
                                {{- if not (empty $action) }}
                                {{- if not (empty $action.Route) }}
                                {{- $path := print "/" $routePath "/" (indirect $action.Route.Path) | trimSuffix "/" }}
                                list: "{{$path}}",
                                {{- end }}
                                {{- end }}

                                {{- $action = ER_getActionByName $n "show" }}
                                {{- if not (empty $action) }}
                                {{- if not (empty $action.Route) }}
                                {{- $path := print "/" $routePath "/" (indirect $action.Route.Path) | trimSuffix "/" }}
                                show: "{{$path}}",
                                {{- end }}
                                {{- end }}

                                {{- $action = ER_getActionByName $n "create" }}
                                {{- if not (empty $action) }}
                                {{- if not (empty $action.Route) }}
                                {{- $path := print "/" $routePath "/" (indirect $action.Route.Path) | trimSuffix "/" }}
                                create: "{{$path}}",
                                {{- end }}
                                {{- end }}

                                {{- $action = ER_getActionByName $n "edit" }}
                                {{- if not (empty $action) }}
                                {{- if not (empty $action.Route) }}
                                {{- $path := print "/" $routePath "/" (indirect $action.Route.Path) | trimSuffix "/" }}
                                edit: "{{$path}}",
                                {{- end }}
                                {{- end }}
                                meta: {
                                    icon: <AntdIcons.{{ default "FileOutlined" $n.Annotations.ENTKIT.Icon}}/>,
                                    {{- if $.Extension.Auth.Enabled}}
                                    hide: !permissions?.{{$n.Name}}?.includes("Read")
                                    {{- end }}
                                }
                            },
                            {{- end}}
                        ]
                    }
                >
                    <RoutesBundle/>
                    <UnsavedChangesNotifier />
                </Refine>
            </ConfigProvider>
        </BrowserRouter>
    );
}

export default App;
{{- end -}}