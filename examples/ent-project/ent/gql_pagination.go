// Copyright 2019-present Facebook
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"encoding/base64"
	"errors"
	"fmt"
	"io"
	"strconv"
	"strings"

	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/company"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/country"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/email"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/image"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/location"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/phone"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/product"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/vendor"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/warehouse"
	"github.com/diazoxide/ent-refine/examples/ent-project/ent/website"
	"github.com/google/uuid"
	"github.com/vektah/gqlparser/v2/gqlerror"
	"github.com/vmihailenco/msgpack/v5"
)

// OrderDirection defines the directions in which to order a list of items.
type OrderDirection string

const (
	// OrderDirectionAsc specifies an ascending order.
	OrderDirectionAsc OrderDirection = "ASC"
	// OrderDirectionDesc specifies a descending order.
	OrderDirectionDesc OrderDirection = "DESC"
)

// Validate the order direction value.
func (o OrderDirection) Validate() error {
	if o != OrderDirectionAsc && o != OrderDirectionDesc {
		return fmt.Errorf("%s is not a valid OrderDirection", o)
	}
	return nil
}

// String implements fmt.Stringer interface.
func (o OrderDirection) String() string {
	return string(o)
}

// MarshalGQL implements graphql.Marshaler interface.
func (o OrderDirection) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(o.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (o *OrderDirection) UnmarshalGQL(val interface{}) error {
	str, ok := val.(string)
	if !ok {
		return fmt.Errorf("order direction %T must be a string", val)
	}
	*o = OrderDirection(str)
	return o.Validate()
}

func (o OrderDirection) reverse() OrderDirection {
	if o == OrderDirectionDesc {
		return OrderDirectionAsc
	}
	return OrderDirectionDesc
}

func (o OrderDirection) orderFunc(field string) OrderFunc {
	if o == OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

func cursorsToPredicates(direction OrderDirection, after, before *Cursor, field, idField string) []func(s *sql.Selector) {
	var predicates []func(s *sql.Selector)
	if after != nil {
		if after.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeGT
			} else {
				predicate = sql.CompositeLT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					after.Value, after.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.GT
			} else {
				predicate = sql.LT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					after.ID,
				))
			})
		}
	}
	if before != nil {
		if before.Value != nil {
			var predicate func([]string, ...interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.CompositeLT
			} else {
				predicate = sql.CompositeGT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.Columns(field, idField),
					before.Value, before.ID,
				))
			})
		} else {
			var predicate func(string, interface{}) *sql.Predicate
			if direction == OrderDirectionAsc {
				predicate = sql.LT
			} else {
				predicate = sql.GT
			}
			predicates = append(predicates, func(s *sql.Selector) {
				s.Where(predicate(
					s.C(idField),
					before.ID,
				))
			})
		}
	}
	return predicates
}

// PageInfo of a connection type.
type PageInfo struct {
	HasNextPage     bool    `json:"hasNextPage"`
	HasPreviousPage bool    `json:"hasPreviousPage"`
	StartCursor     *Cursor `json:"startCursor"`
	EndCursor       *Cursor `json:"endCursor"`
}

// Cursor of an edge type.
type Cursor struct {
	ID    uuid.UUID `msgpack:"i"`
	Value Value     `msgpack:"v,omitempty"`
}

// MarshalGQL implements graphql.Marshaler interface.
func (c Cursor) MarshalGQL(w io.Writer) {
	quote := []byte{'"'}
	w.Write(quote)
	defer w.Write(quote)
	wc := base64.NewEncoder(base64.RawStdEncoding, w)
	defer wc.Close()
	_ = msgpack.NewEncoder(wc).Encode(c)
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (c *Cursor) UnmarshalGQL(v interface{}) error {
	s, ok := v.(string)
	if !ok {
		return fmt.Errorf("%T is not a string", v)
	}
	if err := msgpack.NewDecoder(
		base64.NewDecoder(
			base64.RawStdEncoding,
			strings.NewReader(s),
		),
	).Decode(c); err != nil {
		return fmt.Errorf("cannot decode cursor: %w", err)
	}
	return nil
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// CompanyEdge is the edge representation of Company.
type CompanyEdge struct {
	Node   *Company `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CompanyConnection is the connection containing edges to Company.
type CompanyConnection struct {
	Edges      []*CompanyEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *CompanyConnection) build(nodes []*Company, pager *companyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Company
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Company {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Company {
			return nodes[i]
		}
	}
	c.Edges = make([]*CompanyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CompanyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CompanyPaginateOption enables pagination customization.
type CompanyPaginateOption func(*companyPager) error

// WithCompanyOrder configures pagination ordering.
func WithCompanyOrder(order *CompanyOrder) CompanyPaginateOption {
	if order == nil {
		order = DefaultCompanyOrder
	}
	o := *order
	return func(pager *companyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCompanyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCompanyFilter configures pagination filter.
func WithCompanyFilter(filter func(*CompanyQuery) (*CompanyQuery, error)) CompanyPaginateOption {
	return func(pager *companyPager) error {
		if filter == nil {
			return errors.New("CompanyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type companyPager struct {
	order  *CompanyOrder
	filter func(*CompanyQuery) (*CompanyQuery, error)
}

func newCompanyPager(opts []CompanyPaginateOption) (*companyPager, error) {
	pager := &companyPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCompanyOrder
	}
	return pager, nil
}

func (p *companyPager) applyFilter(query *CompanyQuery) (*CompanyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *companyPager) toCursor(c *Company) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *companyPager) applyCursors(query *CompanyQuery, after, before *Cursor) *CompanyQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCompanyOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *companyPager) applyOrder(query *CompanyQuery, reverse bool) *CompanyQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCompanyOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCompanyOrder.Field.field))
	}
	return query
}

func (p *companyPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCompanyOrder.Field {
			b.Comma().Ident(DefaultCompanyOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Company.
func (c *CompanyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CompanyPaginateOption,
) (*CompanyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCompanyPager(opts)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CompanyConnection{Edges: []*CompanyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CompanyOrderFieldName orders Company by name.
	CompanyOrderFieldName = &CompanyOrderField{
		field: company.FieldName,
		toCursor: func(c *Company) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Name,
			}
		},
	}
	// CompanyOrderFieldLogo orders Company by logo.
	CompanyOrderFieldLogo = &CompanyOrderField{
		field: company.FieldLogo,
		toCursor: func(c *Company) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Logo,
			}
		},
	}
	// CompanyOrderFieldDescription orders Company by description.
	CompanyOrderFieldDescription = &CompanyOrderField{
		field: company.FieldDescription,
		toCursor: func(c *Company) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Description,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CompanyOrderField) String() string {
	var str string
	switch f.field {
	case company.FieldName:
		str = "NAME"
	case company.FieldLogo:
		str = "LOGO"
	case company.FieldDescription:
		str = "DESCRIPTION"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CompanyOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CompanyOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CompanyOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *CompanyOrderFieldName
	case "LOGO":
		*f = *CompanyOrderFieldLogo
	case "DESCRIPTION":
		*f = *CompanyOrderFieldDescription
	default:
		return fmt.Errorf("%s is not a valid CompanyOrderField", str)
	}
	return nil
}

// CompanyOrderField defines the ordering field of Company.
type CompanyOrderField struct {
	field    string
	toCursor func(*Company) Cursor
}

// CompanyOrder defines the ordering of Company.
type CompanyOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CompanyOrderField `json:"field"`
}

// DefaultCompanyOrder is the default ordering of Company.
var DefaultCompanyOrder = &CompanyOrder{
	Direction: OrderDirectionAsc,
	Field: &CompanyOrderField{
		field: company.FieldID,
		toCursor: func(c *Company) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Company into CompanyEdge.
func (c *Company) ToEdge(order *CompanyOrder) *CompanyEdge {
	if order == nil {
		order = DefaultCompanyOrder
	}
	return &CompanyEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CountryEdge is the edge representation of Country.
type CountryEdge struct {
	Node   *Country `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CountryConnection is the connection containing edges to Country.
type CountryConnection struct {
	Edges      []*CountryEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *CountryConnection) build(nodes []*Country, pager *countryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Country
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Country {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Country {
			return nodes[i]
		}
	}
	c.Edges = make([]*CountryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CountryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CountryPaginateOption enables pagination customization.
type CountryPaginateOption func(*countryPager) error

// WithCountryOrder configures pagination ordering.
func WithCountryOrder(order *CountryOrder) CountryPaginateOption {
	if order == nil {
		order = DefaultCountryOrder
	}
	o := *order
	return func(pager *countryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCountryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCountryFilter configures pagination filter.
func WithCountryFilter(filter func(*CountryQuery) (*CountryQuery, error)) CountryPaginateOption {
	return func(pager *countryPager) error {
		if filter == nil {
			return errors.New("CountryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type countryPager struct {
	order  *CountryOrder
	filter func(*CountryQuery) (*CountryQuery, error)
}

func newCountryPager(opts []CountryPaginateOption) (*countryPager, error) {
	pager := &countryPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCountryOrder
	}
	return pager, nil
}

func (p *countryPager) applyFilter(query *CountryQuery) (*CountryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *countryPager) toCursor(c *Country) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *countryPager) applyCursors(query *CountryQuery, after, before *Cursor) *CountryQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultCountryOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *countryPager) applyOrder(query *CountryQuery, reverse bool) *CountryQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultCountryOrder.Field {
		query = query.Order(direction.orderFunc(DefaultCountryOrder.Field.field))
	}
	return query
}

func (p *countryPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCountryOrder.Field {
			b.Comma().Ident(DefaultCountryOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Country.
func (c *CountryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CountryPaginateOption,
) (*CountryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCountryPager(opts)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CountryConnection{Edges: []*CountryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = c.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	c = pager.applyCursors(c, after, before)
	c = pager.applyOrder(c, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// CountryOrderFieldName orders Country by name.
	CountryOrderFieldName = &CountryOrderField{
		field: country.FieldName,
		toCursor: func(c *Country) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Name,
			}
		},
	}
	// CountryOrderFieldCode orders Country by code.
	CountryOrderFieldCode = &CountryOrderField{
		field: country.FieldCode,
		toCursor: func(c *Country) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.Code,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f CountryOrderField) String() string {
	var str string
	switch f.field {
	case country.FieldName:
		str = "NAME"
	case country.FieldCode:
		str = "CODE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f CountryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *CountryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("CountryOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *CountryOrderFieldName
	case "CODE":
		*f = *CountryOrderFieldCode
	default:
		return fmt.Errorf("%s is not a valid CountryOrderField", str)
	}
	return nil
}

// CountryOrderField defines the ordering field of Country.
type CountryOrderField struct {
	field    string
	toCursor func(*Country) Cursor
}

// CountryOrder defines the ordering of Country.
type CountryOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CountryOrderField `json:"field"`
}

// DefaultCountryOrder is the default ordering of Country.
var DefaultCountryOrder = &CountryOrder{
	Direction: OrderDirectionAsc,
	Field: &CountryOrderField{
		field: country.FieldID,
		toCursor: func(c *Country) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Country into CountryEdge.
func (c *Country) ToEdge(order *CountryOrder) *CountryEdge {
	if order == nil {
		order = DefaultCountryOrder
	}
	return &CountryEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// EmailEdge is the edge representation of Email.
type EmailEdge struct {
	Node   *Email `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// EmailConnection is the connection containing edges to Email.
type EmailConnection struct {
	Edges      []*EmailEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *EmailConnection) build(nodes []*Email, pager *emailPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Email
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Email {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Email {
			return nodes[i]
		}
	}
	c.Edges = make([]*EmailEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EmailEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EmailPaginateOption enables pagination customization.
type EmailPaginateOption func(*emailPager) error

// WithEmailOrder configures pagination ordering.
func WithEmailOrder(order *EmailOrder) EmailPaginateOption {
	if order == nil {
		order = DefaultEmailOrder
	}
	o := *order
	return func(pager *emailPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEmailOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEmailFilter configures pagination filter.
func WithEmailFilter(filter func(*EmailQuery) (*EmailQuery, error)) EmailPaginateOption {
	return func(pager *emailPager) error {
		if filter == nil {
			return errors.New("EmailQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type emailPager struct {
	order  *EmailOrder
	filter func(*EmailQuery) (*EmailQuery, error)
}

func newEmailPager(opts []EmailPaginateOption) (*emailPager, error) {
	pager := &emailPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEmailOrder
	}
	return pager, nil
}

func (p *emailPager) applyFilter(query *EmailQuery) (*EmailQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *emailPager) toCursor(e *Email) Cursor {
	return p.order.Field.toCursor(e)
}

func (p *emailPager) applyCursors(query *EmailQuery, after, before *Cursor) *EmailQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultEmailOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *emailPager) applyOrder(query *EmailQuery, reverse bool) *EmailQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultEmailOrder.Field {
		query = query.Order(direction.orderFunc(DefaultEmailOrder.Field.field))
	}
	return query
}

func (p *emailPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEmailOrder.Field {
			b.Comma().Ident(DefaultEmailOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Email.
func (e *EmailQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EmailPaginateOption,
) (*EmailConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEmailPager(opts)
	if err != nil {
		return nil, err
	}
	if e, err = pager.applyFilter(e); err != nil {
		return nil, err
	}
	conn := &EmailConnection{Edges: []*EmailEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = e.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	e = pager.applyCursors(e, after, before)
	e = pager.applyOrder(e, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		e.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := e.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := e.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// EmailOrderFieldTitle orders Email by title.
	EmailOrderFieldTitle = &EmailOrderField{
		field: email.FieldTitle,
		toCursor: func(e *Email) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.Title,
			}
		},
	}
	// EmailOrderFieldDescription orders Email by description.
	EmailOrderFieldDescription = &EmailOrderField{
		field: email.FieldDescription,
		toCursor: func(e *Email) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.Description,
			}
		},
	}
	// EmailOrderFieldAddress orders Email by address.
	EmailOrderFieldAddress = &EmailOrderField{
		field: email.FieldAddress,
		toCursor: func(e *Email) Cursor {
			return Cursor{
				ID:    e.ID,
				Value: e.Address,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f EmailOrderField) String() string {
	var str string
	switch f.field {
	case email.FieldTitle:
		str = "TITLE"
	case email.FieldDescription:
		str = "DESCRIPTION"
	case email.FieldAddress:
		str = "ADDRESS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f EmailOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *EmailOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("EmailOrderField %T must be a string", v)
	}
	switch str {
	case "TITLE":
		*f = *EmailOrderFieldTitle
	case "DESCRIPTION":
		*f = *EmailOrderFieldDescription
	case "ADDRESS":
		*f = *EmailOrderFieldAddress
	default:
		return fmt.Errorf("%s is not a valid EmailOrderField", str)
	}
	return nil
}

// EmailOrderField defines the ordering field of Email.
type EmailOrderField struct {
	field    string
	toCursor func(*Email) Cursor
}

// EmailOrder defines the ordering of Email.
type EmailOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *EmailOrderField `json:"field"`
}

// DefaultEmailOrder is the default ordering of Email.
var DefaultEmailOrder = &EmailOrder{
	Direction: OrderDirectionAsc,
	Field: &EmailOrderField{
		field: email.FieldID,
		toCursor: func(e *Email) Cursor {
			return Cursor{ID: e.ID}
		},
	},
}

// ToEdge converts Email into EmailEdge.
func (e *Email) ToEdge(order *EmailOrder) *EmailEdge {
	if order == nil {
		order = DefaultEmailOrder
	}
	return &EmailEdge{
		Node:   e,
		Cursor: order.Field.toCursor(e),
	}
}

// ImageEdge is the edge representation of Image.
type ImageEdge struct {
	Node   *Image `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ImageConnection is the connection containing edges to Image.
type ImageConnection struct {
	Edges      []*ImageEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *ImageConnection) build(nodes []*Image, pager *imagePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Image
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Image {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Image {
			return nodes[i]
		}
	}
	c.Edges = make([]*ImageEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ImageEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ImagePaginateOption enables pagination customization.
type ImagePaginateOption func(*imagePager) error

// WithImageOrder configures pagination ordering.
func WithImageOrder(order *ImageOrder) ImagePaginateOption {
	if order == nil {
		order = DefaultImageOrder
	}
	o := *order
	return func(pager *imagePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultImageOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithImageFilter configures pagination filter.
func WithImageFilter(filter func(*ImageQuery) (*ImageQuery, error)) ImagePaginateOption {
	return func(pager *imagePager) error {
		if filter == nil {
			return errors.New("ImageQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type imagePager struct {
	order  *ImageOrder
	filter func(*ImageQuery) (*ImageQuery, error)
}

func newImagePager(opts []ImagePaginateOption) (*imagePager, error) {
	pager := &imagePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultImageOrder
	}
	return pager, nil
}

func (p *imagePager) applyFilter(query *ImageQuery) (*ImageQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *imagePager) toCursor(i *Image) Cursor {
	return p.order.Field.toCursor(i)
}

func (p *imagePager) applyCursors(query *ImageQuery, after, before *Cursor) *ImageQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultImageOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *imagePager) applyOrder(query *ImageQuery, reverse bool) *ImageQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultImageOrder.Field {
		query = query.Order(direction.orderFunc(DefaultImageOrder.Field.field))
	}
	return query
}

func (p *imagePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultImageOrder.Field {
			b.Comma().Ident(DefaultImageOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Image.
func (i *ImageQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ImagePaginateOption,
) (*ImageConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newImagePager(opts)
	if err != nil {
		return nil, err
	}
	if i, err = pager.applyFilter(i); err != nil {
		return nil, err
	}
	conn := &ImageConnection{Edges: []*ImageEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = i.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	i = pager.applyCursors(i, after, before)
	i = pager.applyOrder(i, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		i.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := i.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := i.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ImageOrderFieldTitle orders Image by title.
	ImageOrderFieldTitle = &ImageOrderField{
		field: image.FieldTitle,
		toCursor: func(i *Image) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.Title,
			}
		},
	}
	// ImageOrderFieldOriginalURL orders Image by original_url.
	ImageOrderFieldOriginalURL = &ImageOrderField{
		field: image.FieldOriginalURL,
		toCursor: func(i *Image) Cursor {
			return Cursor{
				ID:    i.ID,
				Value: i.OriginalURL,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ImageOrderField) String() string {
	var str string
	switch f.field {
	case image.FieldTitle:
		str = "TITLE"
	case image.FieldOriginalURL:
		str = "ORIGINAL_URL"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ImageOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ImageOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ImageOrderField %T must be a string", v)
	}
	switch str {
	case "TITLE":
		*f = *ImageOrderFieldTitle
	case "ORIGINAL_URL":
		*f = *ImageOrderFieldOriginalURL
	default:
		return fmt.Errorf("%s is not a valid ImageOrderField", str)
	}
	return nil
}

// ImageOrderField defines the ordering field of Image.
type ImageOrderField struct {
	field    string
	toCursor func(*Image) Cursor
}

// ImageOrder defines the ordering of Image.
type ImageOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *ImageOrderField `json:"field"`
}

// DefaultImageOrder is the default ordering of Image.
var DefaultImageOrder = &ImageOrder{
	Direction: OrderDirectionAsc,
	Field: &ImageOrderField{
		field: image.FieldID,
		toCursor: func(i *Image) Cursor {
			return Cursor{ID: i.ID}
		},
	},
}

// ToEdge converts Image into ImageEdge.
func (i *Image) ToEdge(order *ImageOrder) *ImageEdge {
	if order == nil {
		order = DefaultImageOrder
	}
	return &ImageEdge{
		Node:   i,
		Cursor: order.Field.toCursor(i),
	}
}

// LocationEdge is the edge representation of Location.
type LocationEdge struct {
	Node   *Location `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// LocationConnection is the connection containing edges to Location.
type LocationConnection struct {
	Edges      []*LocationEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *LocationConnection) build(nodes []*Location, pager *locationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Location
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Location {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Location {
			return nodes[i]
		}
	}
	c.Edges = make([]*LocationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &LocationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// LocationPaginateOption enables pagination customization.
type LocationPaginateOption func(*locationPager) error

// WithLocationOrder configures pagination ordering.
func WithLocationOrder(order *LocationOrder) LocationPaginateOption {
	if order == nil {
		order = DefaultLocationOrder
	}
	o := *order
	return func(pager *locationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultLocationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithLocationFilter configures pagination filter.
func WithLocationFilter(filter func(*LocationQuery) (*LocationQuery, error)) LocationPaginateOption {
	return func(pager *locationPager) error {
		if filter == nil {
			return errors.New("LocationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type locationPager struct {
	order  *LocationOrder
	filter func(*LocationQuery) (*LocationQuery, error)
}

func newLocationPager(opts []LocationPaginateOption) (*locationPager, error) {
	pager := &locationPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultLocationOrder
	}
	return pager, nil
}

func (p *locationPager) applyFilter(query *LocationQuery) (*LocationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *locationPager) toCursor(l *Location) Cursor {
	return p.order.Field.toCursor(l)
}

func (p *locationPager) applyCursors(query *LocationQuery, after, before *Cursor) *LocationQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultLocationOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *locationPager) applyOrder(query *LocationQuery, reverse bool) *LocationQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultLocationOrder.Field {
		query = query.Order(direction.orderFunc(DefaultLocationOrder.Field.field))
	}
	return query
}

func (p *locationPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultLocationOrder.Field {
			b.Comma().Ident(DefaultLocationOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Location.
func (l *LocationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LocationPaginateOption,
) (*LocationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLocationPager(opts)
	if err != nil {
		return nil, err
	}
	if l, err = pager.applyFilter(l); err != nil {
		return nil, err
	}
	conn := &LocationConnection{Edges: []*LocationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = l.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	l = pager.applyCursors(l, after, before)
	l = pager.applyOrder(l, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		l.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := l.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := l.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// LocationOrderFieldTitle orders Location by title.
	LocationOrderFieldTitle = &LocationOrderField{
		field: location.FieldTitle,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.Title,
			}
		},
	}
	// LocationOrderFieldDescription orders Location by description.
	LocationOrderFieldDescription = &LocationOrderField{
		field: location.FieldDescription,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.Description,
			}
		},
	}
	// LocationOrderFieldLatitude orders Location by latitude.
	LocationOrderFieldLatitude = &LocationOrderField{
		field: location.FieldLatitude,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.Latitude,
			}
		},
	}
	// LocationOrderFieldLongitude orders Location by longitude.
	LocationOrderFieldLongitude = &LocationOrderField{
		field: location.FieldLongitude,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.Longitude,
			}
		},
	}
	// LocationOrderFieldAddress orders Location by address.
	LocationOrderFieldAddress = &LocationOrderField{
		field: location.FieldAddress,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.Address,
			}
		},
	}
	// LocationOrderFieldPostcode orders Location by postcode.
	LocationOrderFieldPostcode = &LocationOrderField{
		field: location.FieldPostcode,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.Postcode,
			}
		},
	}
	// LocationOrderFieldType orders Location by type.
	LocationOrderFieldType = &LocationOrderField{
		field: location.FieldType,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.Type,
			}
		},
	}
	// LocationOrderFieldState orders Location by state.
	LocationOrderFieldState = &LocationOrderField{
		field: location.FieldState,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.State,
			}
		},
	}
	// LocationOrderFieldSuburb orders Location by suburb.
	LocationOrderFieldSuburb = &LocationOrderField{
		field: location.FieldSuburb,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.Suburb,
			}
		},
	}
	// LocationOrderFieldStreetType orders Location by street_type.
	LocationOrderFieldStreetType = &LocationOrderField{
		field: location.FieldStreetType,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.StreetType,
			}
		},
	}
	// LocationOrderFieldStreetName orders Location by street_name.
	LocationOrderFieldStreetName = &LocationOrderField{
		field: location.FieldStreetName,
		toCursor: func(l *Location) Cursor {
			return Cursor{
				ID:    l.ID,
				Value: l.StreetName,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f LocationOrderField) String() string {
	var str string
	switch f.field {
	case location.FieldTitle:
		str = "TITLE"
	case location.FieldDescription:
		str = "DESCRIPTION"
	case location.FieldLatitude:
		str = "LATITUDE"
	case location.FieldLongitude:
		str = "LONGITUDE"
	case location.FieldAddress:
		str = "ADDRESS"
	case location.FieldPostcode:
		str = "POSTCODE"
	case location.FieldType:
		str = "TYPE"
	case location.FieldState:
		str = "STATE"
	case location.FieldSuburb:
		str = "SUBURB"
	case location.FieldStreetType:
		str = "STREET_TYPE"
	case location.FieldStreetName:
		str = "STREET_NAME"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f LocationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *LocationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("LocationOrderField %T must be a string", v)
	}
	switch str {
	case "TITLE":
		*f = *LocationOrderFieldTitle
	case "DESCRIPTION":
		*f = *LocationOrderFieldDescription
	case "LATITUDE":
		*f = *LocationOrderFieldLatitude
	case "LONGITUDE":
		*f = *LocationOrderFieldLongitude
	case "ADDRESS":
		*f = *LocationOrderFieldAddress
	case "POSTCODE":
		*f = *LocationOrderFieldPostcode
	case "TYPE":
		*f = *LocationOrderFieldType
	case "STATE":
		*f = *LocationOrderFieldState
	case "SUBURB":
		*f = *LocationOrderFieldSuburb
	case "STREET_TYPE":
		*f = *LocationOrderFieldStreetType
	case "STREET_NAME":
		*f = *LocationOrderFieldStreetName
	default:
		return fmt.Errorf("%s is not a valid LocationOrderField", str)
	}
	return nil
}

// LocationOrderField defines the ordering field of Location.
type LocationOrderField struct {
	field    string
	toCursor func(*Location) Cursor
}

// LocationOrder defines the ordering of Location.
type LocationOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *LocationOrderField `json:"field"`
}

// DefaultLocationOrder is the default ordering of Location.
var DefaultLocationOrder = &LocationOrder{
	Direction: OrderDirectionAsc,
	Field: &LocationOrderField{
		field: location.FieldID,
		toCursor: func(l *Location) Cursor {
			return Cursor{ID: l.ID}
		},
	},
}

// ToEdge converts Location into LocationEdge.
func (l *Location) ToEdge(order *LocationOrder) *LocationEdge {
	if order == nil {
		order = DefaultLocationOrder
	}
	return &LocationEdge{
		Node:   l,
		Cursor: order.Field.toCursor(l),
	}
}

// PhoneEdge is the edge representation of Phone.
type PhoneEdge struct {
	Node   *Phone `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// PhoneConnection is the connection containing edges to Phone.
type PhoneConnection struct {
	Edges      []*PhoneEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *PhoneConnection) build(nodes []*Phone, pager *phonePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Phone
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Phone {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Phone {
			return nodes[i]
		}
	}
	c.Edges = make([]*PhoneEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PhoneEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PhonePaginateOption enables pagination customization.
type PhonePaginateOption func(*phonePager) error

// WithPhoneOrder configures pagination ordering.
func WithPhoneOrder(order *PhoneOrder) PhonePaginateOption {
	if order == nil {
		order = DefaultPhoneOrder
	}
	o := *order
	return func(pager *phonePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPhoneOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPhoneFilter configures pagination filter.
func WithPhoneFilter(filter func(*PhoneQuery) (*PhoneQuery, error)) PhonePaginateOption {
	return func(pager *phonePager) error {
		if filter == nil {
			return errors.New("PhoneQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type phonePager struct {
	order  *PhoneOrder
	filter func(*PhoneQuery) (*PhoneQuery, error)
}

func newPhonePager(opts []PhonePaginateOption) (*phonePager, error) {
	pager := &phonePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPhoneOrder
	}
	return pager, nil
}

func (p *phonePager) applyFilter(query *PhoneQuery) (*PhoneQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *phonePager) toCursor(ph *Phone) Cursor {
	return p.order.Field.toCursor(ph)
}

func (p *phonePager) applyCursors(query *PhoneQuery, after, before *Cursor) *PhoneQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultPhoneOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *phonePager) applyOrder(query *PhoneQuery, reverse bool) *PhoneQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultPhoneOrder.Field {
		query = query.Order(direction.orderFunc(DefaultPhoneOrder.Field.field))
	}
	return query
}

func (p *phonePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPhoneOrder.Field {
			b.Comma().Ident(DefaultPhoneOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Phone.
func (ph *PhoneQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PhonePaginateOption,
) (*PhoneConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPhonePager(opts)
	if err != nil {
		return nil, err
	}
	if ph, err = pager.applyFilter(ph); err != nil {
		return nil, err
	}
	conn := &PhoneConnection{Edges: []*PhoneEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = ph.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	ph = pager.applyCursors(ph, after, before)
	ph = pager.applyOrder(ph, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		ph.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ph.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := ph.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// PhoneOrderFieldTitle orders Phone by title.
	PhoneOrderFieldTitle = &PhoneOrderField{
		field: phone.FieldTitle,
		toCursor: func(ph *Phone) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.Title,
			}
		},
	}
	// PhoneOrderFieldDescription orders Phone by description.
	PhoneOrderFieldDescription = &PhoneOrderField{
		field: phone.FieldDescription,
		toCursor: func(ph *Phone) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.Description,
			}
		},
	}
	// PhoneOrderFieldNumber orders Phone by number.
	PhoneOrderFieldNumber = &PhoneOrderField{
		field: phone.FieldNumber,
		toCursor: func(ph *Phone) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.Number,
			}
		},
	}
	// PhoneOrderFieldType orders Phone by type.
	PhoneOrderFieldType = &PhoneOrderField{
		field: phone.FieldType,
		toCursor: func(ph *Phone) Cursor {
			return Cursor{
				ID:    ph.ID,
				Value: ph.Type,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f PhoneOrderField) String() string {
	var str string
	switch f.field {
	case phone.FieldTitle:
		str = "TITLE"
	case phone.FieldDescription:
		str = "DESCRIPTION"
	case phone.FieldNumber:
		str = "NUMBER"
	case phone.FieldType:
		str = "TYPE"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f PhoneOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *PhoneOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("PhoneOrderField %T must be a string", v)
	}
	switch str {
	case "TITLE":
		*f = *PhoneOrderFieldTitle
	case "DESCRIPTION":
		*f = *PhoneOrderFieldDescription
	case "NUMBER":
		*f = *PhoneOrderFieldNumber
	case "TYPE":
		*f = *PhoneOrderFieldType
	default:
		return fmt.Errorf("%s is not a valid PhoneOrderField", str)
	}
	return nil
}

// PhoneOrderField defines the ordering field of Phone.
type PhoneOrderField struct {
	field    string
	toCursor func(*Phone) Cursor
}

// PhoneOrder defines the ordering of Phone.
type PhoneOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *PhoneOrderField `json:"field"`
}

// DefaultPhoneOrder is the default ordering of Phone.
var DefaultPhoneOrder = &PhoneOrder{
	Direction: OrderDirectionAsc,
	Field: &PhoneOrderField{
		field: phone.FieldID,
		toCursor: func(ph *Phone) Cursor {
			return Cursor{ID: ph.ID}
		},
	},
}

// ToEdge converts Phone into PhoneEdge.
func (ph *Phone) ToEdge(order *PhoneOrder) *PhoneEdge {
	if order == nil {
		order = DefaultPhoneOrder
	}
	return &PhoneEdge{
		Node:   ph,
		Cursor: order.Field.toCursor(ph),
	}
}

// ProductEdge is the edge representation of Product.
type ProductEdge struct {
	Node   *Product `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProductConnection is the connection containing edges to Product.
type ProductConnection struct {
	Edges      []*ProductEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProductConnection) build(nodes []*Product, pager *productPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Product
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Product {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Product {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProductEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProductEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProductPaginateOption enables pagination customization.
type ProductPaginateOption func(*productPager) error

// WithProductOrder configures pagination ordering.
func WithProductOrder(order *ProductOrder) ProductPaginateOption {
	if order == nil {
		order = DefaultProductOrder
	}
	o := *order
	return func(pager *productPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProductOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProductFilter configures pagination filter.
func WithProductFilter(filter func(*ProductQuery) (*ProductQuery, error)) ProductPaginateOption {
	return func(pager *productPager) error {
		if filter == nil {
			return errors.New("ProductQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type productPager struct {
	order  *ProductOrder
	filter func(*ProductQuery) (*ProductQuery, error)
}

func newProductPager(opts []ProductPaginateOption) (*productPager, error) {
	pager := &productPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProductOrder
	}
	return pager, nil
}

func (p *productPager) applyFilter(query *ProductQuery) (*ProductQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *productPager) toCursor(pr *Product) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *productPager) applyCursors(query *ProductQuery, after, before *Cursor) *ProductQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultProductOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *productPager) applyOrder(query *ProductQuery, reverse bool) *ProductQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultProductOrder.Field {
		query = query.Order(direction.orderFunc(DefaultProductOrder.Field.field))
	}
	return query
}

func (p *productPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProductOrder.Field {
			b.Comma().Ident(DefaultProductOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Product.
func (pr *ProductQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProductPaginateOption,
) (*ProductConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProductPager(opts)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &ProductConnection{Edges: []*ProductEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = pr.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	pr = pager.applyCursors(pr, after, before)
	pr = pager.applyOrder(pr, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ProductOrderFieldName orders Product by name.
	ProductOrderFieldName = &ProductOrderField{
		field: product.FieldName,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Name,
			}
		},
	}
	// ProductOrderFieldDescription orders Product by description.
	ProductOrderFieldDescription = &ProductOrderField{
		field: product.FieldDescription,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Description,
			}
		},
	}
	// ProductOrderFieldImage orders Product by image.
	ProductOrderFieldImage = &ProductOrderField{
		field: product.FieldImage,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Image,
			}
		},
	}
	// ProductOrderFieldURL orders Product by url.
	ProductOrderFieldURL = &ProductOrderField{
		field: product.FieldURL,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.URL,
			}
		},
	}
	// ProductOrderFieldLastSell orders Product by last_sell.
	ProductOrderFieldLastSell = &ProductOrderField{
		field: product.FieldLastSell,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.LastSell,
			}
		},
	}
	// ProductOrderFieldCreatedAt orders Product by created_at.
	ProductOrderFieldCreatedAt = &ProductOrderField{
		field: product.FieldCreatedAt,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.CreatedAt,
			}
		},
	}
	// ProductOrderFieldStatus orders Product by status.
	ProductOrderFieldStatus = &ProductOrderField{
		field: product.FieldStatus,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.Status,
			}
		},
	}
	// ProductOrderFieldBuildStatus orders Product by build_status.
	ProductOrderFieldBuildStatus = &ProductOrderField{
		field: product.FieldBuildStatus,
		toCursor: func(pr *Product) Cursor {
			return Cursor{
				ID:    pr.ID,
				Value: pr.BuildStatus,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ProductOrderField) String() string {
	var str string
	switch f.field {
	case product.FieldName:
		str = "TITLE"
	case product.FieldDescription:
		str = "DESCRIPTION"
	case product.FieldImage:
		str = "IMAGE"
	case product.FieldURL:
		str = "URL"
	case product.FieldLastSell:
		str = "LAST_SELL"
	case product.FieldCreatedAt:
		str = "CREATED_AT"
	case product.FieldStatus:
		str = "STATUS"
	case product.FieldBuildStatus:
		str = "BUILD_STATUS"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ProductOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ProductOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ProductOrderField %T must be a string", v)
	}
	switch str {
	case "TITLE":
		*f = *ProductOrderFieldName
	case "DESCRIPTION":
		*f = *ProductOrderFieldDescription
	case "IMAGE":
		*f = *ProductOrderFieldImage
	case "URL":
		*f = *ProductOrderFieldURL
	case "LAST_SELL":
		*f = *ProductOrderFieldLastSell
	case "CREATED_AT":
		*f = *ProductOrderFieldCreatedAt
	case "STATUS":
		*f = *ProductOrderFieldStatus
	case "BUILD_STATUS":
		*f = *ProductOrderFieldBuildStatus
	default:
		return fmt.Errorf("%s is not a valid ProductOrderField", str)
	}
	return nil
}

// ProductOrderField defines the ordering field of Product.
type ProductOrderField struct {
	field    string
	toCursor func(*Product) Cursor
}

// ProductOrder defines the ordering of Product.
type ProductOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProductOrderField `json:"field"`
}

// DefaultProductOrder is the default ordering of Product.
var DefaultProductOrder = &ProductOrder{
	Direction: OrderDirectionAsc,
	Field: &ProductOrderField{
		field: product.FieldID,
		toCursor: func(pr *Product) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Product into ProductEdge.
func (pr *Product) ToEdge(order *ProductOrder) *ProductEdge {
	if order == nil {
		order = DefaultProductOrder
	}
	return &ProductEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// VendorEdge is the edge representation of Vendor.
type VendorEdge struct {
	Node   *Vendor `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// VendorConnection is the connection containing edges to Vendor.
type VendorConnection struct {
	Edges      []*VendorEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *VendorConnection) build(nodes []*Vendor, pager *vendorPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Vendor
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Vendor {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Vendor {
			return nodes[i]
		}
	}
	c.Edges = make([]*VendorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &VendorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// VendorPaginateOption enables pagination customization.
type VendorPaginateOption func(*vendorPager) error

// WithVendorOrder configures pagination ordering.
func WithVendorOrder(order *VendorOrder) VendorPaginateOption {
	if order == nil {
		order = DefaultVendorOrder
	}
	o := *order
	return func(pager *vendorPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultVendorOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithVendorFilter configures pagination filter.
func WithVendorFilter(filter func(*VendorQuery) (*VendorQuery, error)) VendorPaginateOption {
	return func(pager *vendorPager) error {
		if filter == nil {
			return errors.New("VendorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type vendorPager struct {
	order  *VendorOrder
	filter func(*VendorQuery) (*VendorQuery, error)
}

func newVendorPager(opts []VendorPaginateOption) (*vendorPager, error) {
	pager := &vendorPager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultVendorOrder
	}
	return pager, nil
}

func (p *vendorPager) applyFilter(query *VendorQuery) (*VendorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *vendorPager) toCursor(v *Vendor) Cursor {
	return p.order.Field.toCursor(v)
}

func (p *vendorPager) applyCursors(query *VendorQuery, after, before *Cursor) *VendorQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultVendorOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *vendorPager) applyOrder(query *VendorQuery, reverse bool) *VendorQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultVendorOrder.Field {
		query = query.Order(direction.orderFunc(DefaultVendorOrder.Field.field))
	}
	return query
}

func (p *vendorPager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultVendorOrder.Field {
			b.Comma().Ident(DefaultVendorOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Vendor.
func (v *VendorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...VendorPaginateOption,
) (*VendorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newVendorPager(opts)
	if err != nil {
		return nil, err
	}
	if v, err = pager.applyFilter(v); err != nil {
		return nil, err
	}
	conn := &VendorConnection{Edges: []*VendorEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = v.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	v = pager.applyCursors(v, after, before)
	v = pager.applyOrder(v, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		v.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := v.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := v.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// VendorOrderFieldName orders Vendor by name.
	VendorOrderFieldName = &VendorOrderField{
		field: vendor.FieldName,
		toCursor: func(v *Vendor) Cursor {
			return Cursor{
				ID:    v.ID,
				Value: v.Name,
			}
		},
	}
	// VendorOrderFieldSchema orders Vendor by schema.
	VendorOrderFieldSchema = &VendorOrderField{
		field: vendor.FieldSchema,
		toCursor: func(v *Vendor) Cursor {
			return Cursor{
				ID:    v.ID,
				Value: v.Schema,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f VendorOrderField) String() string {
	var str string
	switch f.field {
	case vendor.FieldName:
		str = "NAME"
	case vendor.FieldSchema:
		str = "SCHEMA"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f VendorOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *VendorOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("VendorOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *VendorOrderFieldName
	case "SCHEMA":
		*f = *VendorOrderFieldSchema
	default:
		return fmt.Errorf("%s is not a valid VendorOrderField", str)
	}
	return nil
}

// VendorOrderField defines the ordering field of Vendor.
type VendorOrderField struct {
	field    string
	toCursor func(*Vendor) Cursor
}

// VendorOrder defines the ordering of Vendor.
type VendorOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *VendorOrderField `json:"field"`
}

// DefaultVendorOrder is the default ordering of Vendor.
var DefaultVendorOrder = &VendorOrder{
	Direction: OrderDirectionAsc,
	Field: &VendorOrderField{
		field: vendor.FieldID,
		toCursor: func(v *Vendor) Cursor {
			return Cursor{ID: v.ID}
		},
	},
}

// ToEdge converts Vendor into VendorEdge.
func (v *Vendor) ToEdge(order *VendorOrder) *VendorEdge {
	if order == nil {
		order = DefaultVendorOrder
	}
	return &VendorEdge{
		Node:   v,
		Cursor: order.Field.toCursor(v),
	}
}

// WarehouseEdge is the edge representation of Warehouse.
type WarehouseEdge struct {
	Node   *Warehouse `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// WarehouseConnection is the connection containing edges to Warehouse.
type WarehouseConnection struct {
	Edges      []*WarehouseEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *WarehouseConnection) build(nodes []*Warehouse, pager *warehousePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Warehouse
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Warehouse {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Warehouse {
			return nodes[i]
		}
	}
	c.Edges = make([]*WarehouseEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WarehouseEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WarehousePaginateOption enables pagination customization.
type WarehousePaginateOption func(*warehousePager) error

// WithWarehouseOrder configures pagination ordering.
func WithWarehouseOrder(order *WarehouseOrder) WarehousePaginateOption {
	if order == nil {
		order = DefaultWarehouseOrder
	}
	o := *order
	return func(pager *warehousePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWarehouseOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWarehouseFilter configures pagination filter.
func WithWarehouseFilter(filter func(*WarehouseQuery) (*WarehouseQuery, error)) WarehousePaginateOption {
	return func(pager *warehousePager) error {
		if filter == nil {
			return errors.New("WarehouseQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type warehousePager struct {
	order  *WarehouseOrder
	filter func(*WarehouseQuery) (*WarehouseQuery, error)
}

func newWarehousePager(opts []WarehousePaginateOption) (*warehousePager, error) {
	pager := &warehousePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWarehouseOrder
	}
	return pager, nil
}

func (p *warehousePager) applyFilter(query *WarehouseQuery) (*WarehouseQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *warehousePager) toCursor(w *Warehouse) Cursor {
	return p.order.Field.toCursor(w)
}

func (p *warehousePager) applyCursors(query *WarehouseQuery, after, before *Cursor) *WarehouseQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultWarehouseOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *warehousePager) applyOrder(query *WarehouseQuery, reverse bool) *WarehouseQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultWarehouseOrder.Field {
		query = query.Order(direction.orderFunc(DefaultWarehouseOrder.Field.field))
	}
	return query
}

func (p *warehousePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWarehouseOrder.Field {
			b.Comma().Ident(DefaultWarehouseOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Warehouse.
func (w *WarehouseQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WarehousePaginateOption,
) (*WarehouseConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWarehousePager(opts)
	if err != nil {
		return nil, err
	}
	if w, err = pager.applyFilter(w); err != nil {
		return nil, err
	}
	conn := &WarehouseConnection{Edges: []*WarehouseEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = w.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	w = pager.applyCursors(w, after, before)
	w = pager.applyOrder(w, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		w.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := w.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := w.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WarehouseOrderFieldName orders Warehouse by name.
	WarehouseOrderFieldName = &WarehouseOrderField{
		field: warehouse.FieldName,
		toCursor: func(w *Warehouse) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.Name,
			}
		},
	}
	// WarehouseOrderFieldLastUpdate orders Warehouse by last_update.
	WarehouseOrderFieldLastUpdate = &WarehouseOrderField{
		field: warehouse.FieldLastUpdate,
		toCursor: func(w *Warehouse) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.LastUpdate,
			}
		},
	}
	// WarehouseOrderFieldEnabled orders Warehouse by enabled.
	WarehouseOrderFieldEnabled = &WarehouseOrderField{
		field: warehouse.FieldEnabled,
		toCursor: func(w *Warehouse) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.Enabled,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WarehouseOrderField) String() string {
	var str string
	switch f.field {
	case warehouse.FieldName:
		str = "NAME"
	case warehouse.FieldLastUpdate:
		str = "LAST_UPDATE"
	case warehouse.FieldEnabled:
		str = "ENABLED"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WarehouseOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WarehouseOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WarehouseOrderField %T must be a string", v)
	}
	switch str {
	case "NAME":
		*f = *WarehouseOrderFieldName
	case "LAST_UPDATE":
		*f = *WarehouseOrderFieldLastUpdate
	case "ENABLED":
		*f = *WarehouseOrderFieldEnabled
	default:
		return fmt.Errorf("%s is not a valid WarehouseOrderField", str)
	}
	return nil
}

// WarehouseOrderField defines the ordering field of Warehouse.
type WarehouseOrderField struct {
	field    string
	toCursor func(*Warehouse) Cursor
}

// WarehouseOrder defines the ordering of Warehouse.
type WarehouseOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *WarehouseOrderField `json:"field"`
}

// DefaultWarehouseOrder is the default ordering of Warehouse.
var DefaultWarehouseOrder = &WarehouseOrder{
	Direction: OrderDirectionAsc,
	Field: &WarehouseOrderField{
		field: warehouse.FieldID,
		toCursor: func(w *Warehouse) Cursor {
			return Cursor{ID: w.ID}
		},
	},
}

// ToEdge converts Warehouse into WarehouseEdge.
func (w *Warehouse) ToEdge(order *WarehouseOrder) *WarehouseEdge {
	if order == nil {
		order = DefaultWarehouseOrder
	}
	return &WarehouseEdge{
		Node:   w,
		Cursor: order.Field.toCursor(w),
	}
}

// WebsiteEdge is the edge representation of Website.
type WebsiteEdge struct {
	Node   *Website `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// WebsiteConnection is the connection containing edges to Website.
type WebsiteConnection struct {
	Edges      []*WebsiteEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *WebsiteConnection) build(nodes []*Website, pager *websitePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Website
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Website {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Website {
			return nodes[i]
		}
	}
	c.Edges = make([]*WebsiteEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WebsiteEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WebsitePaginateOption enables pagination customization.
type WebsitePaginateOption func(*websitePager) error

// WithWebsiteOrder configures pagination ordering.
func WithWebsiteOrder(order *WebsiteOrder) WebsitePaginateOption {
	if order == nil {
		order = DefaultWebsiteOrder
	}
	o := *order
	return func(pager *websitePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWebsiteOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWebsiteFilter configures pagination filter.
func WithWebsiteFilter(filter func(*WebsiteQuery) (*WebsiteQuery, error)) WebsitePaginateOption {
	return func(pager *websitePager) error {
		if filter == nil {
			return errors.New("WebsiteQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type websitePager struct {
	order  *WebsiteOrder
	filter func(*WebsiteQuery) (*WebsiteQuery, error)
}

func newWebsitePager(opts []WebsitePaginateOption) (*websitePager, error) {
	pager := &websitePager{}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWebsiteOrder
	}
	return pager, nil
}

func (p *websitePager) applyFilter(query *WebsiteQuery) (*WebsiteQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *websitePager) toCursor(w *Website) Cursor {
	return p.order.Field.toCursor(w)
}

func (p *websitePager) applyCursors(query *WebsiteQuery, after, before *Cursor) *WebsiteQuery {
	for _, predicate := range cursorsToPredicates(
		p.order.Direction, after, before,
		p.order.Field.field, DefaultWebsiteOrder.Field.field,
	) {
		query = query.Where(predicate)
	}
	return query
}

func (p *websitePager) applyOrder(query *WebsiteQuery, reverse bool) *WebsiteQuery {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	query = query.Order(direction.orderFunc(p.order.Field.field))
	if p.order.Field != DefaultWebsiteOrder.Field {
		query = query.Order(direction.orderFunc(DefaultWebsiteOrder.Field.field))
	}
	return query
}

func (p *websitePager) orderExpr(reverse bool) sql.Querier {
	direction := p.order.Direction
	if reverse {
		direction = direction.reverse()
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.field).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWebsiteOrder.Field {
			b.Comma().Ident(DefaultWebsiteOrder.Field.field).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Website.
func (w *WebsiteQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WebsitePaginateOption,
) (*WebsiteConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWebsitePager(opts)
	if err != nil {
		return nil, err
	}
	if w, err = pager.applyFilter(w); err != nil {
		return nil, err
	}
	conn := &WebsiteConnection{Edges: []*WebsiteEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			if conn.TotalCount, err = w.Clone().Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}

	w = pager.applyCursors(w, after, before)
	w = pager.applyOrder(w, last != nil)
	if limit := paginateLimit(first, last); limit != 0 {
		w.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := w.collectField(ctx, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}

	nodes, err := w.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// WebsiteOrderFieldTitle orders Website by title.
	WebsiteOrderFieldTitle = &WebsiteOrderField{
		field: website.FieldTitle,
		toCursor: func(w *Website) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.Title,
			}
		},
	}
	// WebsiteOrderFieldDescription orders Website by description.
	WebsiteOrderFieldDescription = &WebsiteOrderField{
		field: website.FieldDescription,
		toCursor: func(w *Website) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.Description,
			}
		},
	}
	// WebsiteOrderFieldURL orders Website by url.
	WebsiteOrderFieldURL = &WebsiteOrderField{
		field: website.FieldURL,
		toCursor: func(w *Website) Cursor {
			return Cursor{
				ID:    w.ID,
				Value: w.URL,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f WebsiteOrderField) String() string {
	var str string
	switch f.field {
	case website.FieldTitle:
		str = "TITLE"
	case website.FieldDescription:
		str = "DESCRIPTION"
	case website.FieldURL:
		str = "URL"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f WebsiteOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *WebsiteOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("WebsiteOrderField %T must be a string", v)
	}
	switch str {
	case "TITLE":
		*f = *WebsiteOrderFieldTitle
	case "DESCRIPTION":
		*f = *WebsiteOrderFieldDescription
	case "URL":
		*f = *WebsiteOrderFieldURL
	default:
		return fmt.Errorf("%s is not a valid WebsiteOrderField", str)
	}
	return nil
}

// WebsiteOrderField defines the ordering field of Website.
type WebsiteOrderField struct {
	field    string
	toCursor func(*Website) Cursor
}

// WebsiteOrder defines the ordering of Website.
type WebsiteOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *WebsiteOrderField `json:"field"`
}

// DefaultWebsiteOrder is the default ordering of Website.
var DefaultWebsiteOrder = &WebsiteOrder{
	Direction: OrderDirectionAsc,
	Field: &WebsiteOrderField{
		field: website.FieldID,
		toCursor: func(w *Website) Cursor {
			return Cursor{ID: w.ID}
		},
	},
}

// ToEdge converts Website into WebsiteEdge.
func (w *Website) ToEdge(order *WebsiteOrder) *WebsiteEdge {
	if order == nil {
		order = DefaultWebsiteOrder
	}
	return &WebsiteEdge{
		Node:   w,
		Cursor: order.Field.toCursor(w),
	}
}
